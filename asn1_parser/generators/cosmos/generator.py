import os
import pathlib
from typing import List, Optional, Any

from asn1_parser.asn1.asn1_bundle import ASN1Bundle
from asn1_parser.asn1.grammar_elements.array import Array
from asn1_parser.asn1.grammar_elements.asn1_module import Asn1Module
from asn1_parser.asn1.grammar_elements.asn1_string import Asn1String
from asn1_parser.asn1.grammar_elements.choice import Choice
from asn1_parser.asn1.grammar_elements.components_item import ComponentsItem
from asn1_parser.asn1.grammar_elements.definitions import Definitions
from asn1_parser.asn1.grammar_elements.enumerated import Enumerated
from asn1_parser.asn1.grammar_elements.sequence import Sequence
from asn1_parser.asn1.grammar_elements.simple_definition import SimpleDefinition
from asn1_parser.asn1.grammar_elements.with_components import WithComponents
from asn1_parser.asn1.validation.asn1_bundle_validator import (
    ASN1ConsistencyError,
)
from asn1_parser.cli.cli_arg_parser import GenerateCosmosCommandConfig
from asn1_parser.generators.cosmos.telemetry import (
    TelemetryEntry,
    RedYellowRange,
)
from asn1_parser.generators.cosmos.templates import cosmos_telemetry
from asn1_parser.log.logger import Logger
from asn1_parser.utils.array import flatten
from asn1_parser.utils.size import (
    DOUBLE_MAX,
    DOUBLE_MIN,
    FLOAT_MAX,
    FLOAT_MIN,
    TypeEnum,
    get_bit_size,
)


ASN1_KEY_CCSDS_APID = "application-process-identifier"


class COSMOSGenerator:
    _logger = Logger(__name__)

    @classmethod
    def generate_cosmos(
        cls,
        config: GenerateCosmosCommandConfig,
        bundle: ASN1Bundle,
    ) -> None:

        asn1_model = bundle.get_module(config.asn1_modules[0])

        types_to_generate: List[str] = config.asn1_messages
        target_name: str = config.output_file_name
        output_folder_base: str = config.output_dir

        telemetry_packets: List[str] = []

        # get the definitions which should be visible in COSMOS as a packet
        definitions = []
        if asn1_model is not None:
            definitions = asn1_model.get_definitions()
        definitions_dict = {d.get_type_name(): d for d in definitions}

        # check for undefined types
        undefined = set(types_to_generate) - set(definitions_dict.keys())
        if undefined:
            raise Exception(f"can not generate undefined types: {undefined}")

        # generate a COSMOS packet for each selected definition
        for definition_name in types_to_generate:
            definition = definitions_dict[definition_name]
            pkt_name = definition.get_type_name()
            module_name = ""
            if asn1_model is not None:
                module_name = asn1_model.get_module_name()
            cls._logger.info(
                f"start processing '{module_name}' - " + f"'{pkt_name}'"
            )
            target_comment: str = ""
            if definition.get_comment() is not None:
                target_comment = definition.get_comment().get_comment()

            telemetry_items: List[TelemetryEntry] = []
            # fetch all nesseccary data for a packet item and put it into the
            # storing list
            if asn1_model is None:
                raise TypeError("None type for asn1_model not allowed.")
            cls._create_telemetry_item_data(
                telemetry_items_list=telemetry_items,
                definition=definition,
                asn1_model=asn1_model,
                with_comp=None,
            )
            # write COSMOS style data representation of the packet
            telemetry_pkt = cosmos_telemetry(
                target_name, target_comment, pkt_name, telemetry_items
            )
            telemetry_packets.append(telemetry_pkt)
            cls._logger.debug(telemetry_pkt)

        # save the COSMOS packets into a file

        output_filepath = os.path.join(output_folder_base, target_name + ".txt")

        cls._logger.info(f"writing to '{output_filepath}'")

        output_folder = os.path.dirname(output_filepath)
        if not os.path.isdir(output_folder):
            pathlib.Path(output_folder).mkdir(parents=True, exist_ok=True)

        with open(file=output_filepath, mode="a", encoding="utf-8") as out:
            out.write("# This file was autogenerated from ASN.1 model.\n")

            for pkt in telemetry_packets:
                out.write("\n")
                out.write(pkt)

    @classmethod
    def _create_telemetry_item_data(
        cls,
        telemetry_items_list: List[TelemetryEntry],
        definition: Definitions,
        asn1_model: Optional[Asn1Module],
        with_comp: Optional[List[ComponentsItem]],
    ) -> None:
        # TODO ASN.1 CHOICE currently not supported
        if isinstance(definition, Sequence):
            for seq_item in definition.get_children():
                item_name: str = seq_item.get_key()

                with_components: WithComponents = seq_item.get_with_components()
                components_list: List[ComponentsItem] = []
                if with_components:
                    components_list = with_components.get_components()
                specific_value: str = ""
                # go through WITH COMPONENTS
                if with_comp:
                    spec_val: List[str] = [
                        c.get_value()
                        for c in with_comp
                        if c.get_key() == item_name
                    ]
                    if len(spec_val) == 1:
                        specific_value = spec_val[0]
                        if isinstance(specific_value, WithComponents):
                            inner_components_list: List[
                                ComponentsItem
                            ] = specific_value.get_components()
                            components_list.extend(inner_components_list)

                comment: str = ""
                unit: str = ""
                little_endian: Optional[bool] = None
                if seq_item.get_comment() is not None:
                    comment = seq_item.get_comment().get_comment()
                    unit = seq_item.get_comment().get_unit()
                    little_endian = (
                        seq_item.get_comment().is_item_little_endian()
                    )
                begin: float = seq_item.get_asn_type().get_begin()
                end: float = seq_item.get_asn_type().get_end()

                state_list: List[str] = []

                seq_type = seq_item.get_asn_type().get_type()
                seq_type_name: str = seq_item.get_asn_type().get_type_name()
                c_type: Optional[
                    TypeEnum
                ] = seq_item.get_asn_type().get_c_type()
                # resolve ASN.1 types directly
                if seq_type_name in ("INTEGER", "REAL"):
                    pass
                elif seq_type_name == "BOOLEAN":
                    state_list.append("False")
                    state_list.append("True")
                elif isinstance(seq_type, Asn1String):
                    end = seq_type.get_length()
                else:
                    # if not an ASN.1 type get the definition of the new type
                    inner_definition: Definitions = cls._get_definition(
                        seq_type_name, asn1_model
                    )
                    if isinstance(inner_definition, SimpleDefinition):
                        # if it is a simple definition do not start a recursion
                        # but resolve the data
                        c_type = inner_definition.get_asn_type().get_c_type()
                        begin = inner_definition.get_asn_type().get_begin()
                        end = inner_definition.get_asn_type().get_end()
                    elif isinstance(inner_definition, Enumerated):
                        # if it is an enumerated do not start a recursion but
                        # resolve the data
                        state_list = inner_definition.get_states()
                        c_type = TypeEnum.A_UINT
                        begin = 0
                        end = len(state_list) - 1
                    else:
                        # resolve definitions recursively
                        cls._create_telemetry_item_data(
                            telemetry_items_list=telemetry_items_list,
                            definition=inner_definition,
                            asn1_model=asn1_model,
                            with_comp=components_list,
                        )
                        continue

                if c_type is None:
                    raise NotImplementedError(
                        f"c_type is None for {seq_type_name}. "
                        "The value should never be None."
                    )
                bitsize: int = get_bit_size(c_type, begin, end)

                red_yellow_range = cls._range_subrange_data_type(
                    c_type, begin, end
                )

                is_array = isinstance(seq_type, Array)
                if is_array:
                    specific_value = str(seq_type.get_length() * bitsize)
                elif seq_item.get_key() == ASN1_KEY_CCSDS_APID:
                    specific_value = f"0x{specific_value:02X}"
                else:
                    specific_value = str(specific_value)

                telemetry_items_list.append(
                    TelemetryEntry(
                        item_name,
                        bitsize,
                        c_type,
                        specific_value,
                        comment,
                        unit,
                        red_yellow_range,
                        state_list,
                        is_array,
                        little_endian,
                    )
                )
        elif isinstance(definition, Choice):
            # choice_list = definition.get_choice()
            # TODO
            raise NotImplementedError(
                "CHOICE currently can't be converted into COSMOS"
            )
        else:
            raise Exception(f"unknown '{definition}' processing")

    @classmethod
    def _get_definitions_recurs(
        cls, type_name: str, asn1_model: Optional[Asn1Module]
    ) -> List[Definitions]:
        # search for the definition in current module

        module_definitions: List[Definitions] = []
        if asn1_model is not None:
            module_definitions = asn1_model.get_definitions()

        # search for the definition in imported modules
        imported_definitions: List[Definitions] = []
        if asn1_model is not None:
            imported_definitions = flatten(
                [
                    cls._get_definitions_recurs(type_name, module)
                    for module in asn1_model.get_imported_modules()
                ]
            )

        # filter by name

        all_def = module_definitions + imported_definitions

        matching_def = [d for d in all_def if d.get_type_name() == type_name]

        # remove duplicated objects

        return list(set(matching_def))

    @classmethod
    def _get_definition(
        cls, type_name: Any, asn1_model: Optional[Asn1Module]
    ) -> Definitions:
        if isinstance(type_name, Array):
            name = type_name.get_asn_type().get_type_name()
        else:
            name = type_name

        definitions = cls._get_definitions_recurs(name, asn1_model)

        if len(definitions) == 1:
            return definitions[0]
        raise ASN1ConsistencyError(
            f"Type '{type_name}' is defined {len(definitions)} times, "
            f"expected 1 definition"
        )

    @classmethod
    def _range_subrange_data_type(
        cls, c_type: str, begin: float, end: float
    ) -> Optional[RedYellowRange]:
        # check if the given range is a sub range of the range of the type
        if (  # pylint: disable=too-many-boolean-expressions
            c_type == TypeEnum.A_FLOAT
            and (begin > FLOAT_MIN or end < FLOAT_MAX)
        ) or (
            c_type == TypeEnum.A_DOUBLE
            and (begin > DOUBLE_MIN or end < DOUBLE_MAX)
        ):
            return RedYellowRange(begin, begin, end, end)
        # TODO check for (u)int range
        return None
